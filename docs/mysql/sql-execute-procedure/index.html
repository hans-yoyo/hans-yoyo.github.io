<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-mysql/一条SQL的执行过程">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">一条SQL的执行过程 | HuHan 的个人网站</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://huhan.tech/docs/mysql/sql-execute-procedure"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="一条SQL的执行过程 | HuHan 的个人网站"><meta data-rh="true" name="description" content="一条SQL的执行过程解析"><meta data-rh="true" property="og:description" content="一条SQL的执行过程解析"><meta data-rh="true" name="keywords" content="MySQL"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://huhan.tech/docs/mysql/sql-execute-procedure"><link data-rh="true" rel="alternate" href="https://huhan.tech/docs/mysql/sql-execute-procedure" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://huhan.tech/docs/mysql/sql-execute-procedure" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="HuHan 的个人网站 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="HuHan 的个人网站 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.8fa9589d.css">
<link rel="preload" href="/assets/js/runtime~main.a5c98095.js" as="script">
<link rel="preload" href="/assets/js/main.e7217a4b.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">学习笔记</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">开发手册</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/wiki/programming-language">程序设计语言</a></li><li><a class="dropdown__link" href="/wiki/spring">Spring</a></li><li><a class="dropdown__link" href="/wiki/database">数据库系统</a></li><li><a class="dropdown__link" href="/wiki/datastructures-algorithms">数据结构与算法</a></li></ul></div><a class="navbar__item navbar__link" href="/blog">博客</a><a class="navbar__item navbar__link" href="/life">👩‍👩‍👦 生活</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/links">资源</a><a href="https://github.com/hans-yoyo/hans-yoyo.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></a><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">本站说明</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/java">JAVA</a><button aria-label="打开/收起侧边栏菜单「JAVA」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/mysql">MySQL</a><button aria-label="打开/收起侧边栏菜单「MySQL」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/syntax-operate">MySQL语法基础-操作篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/syntax-admin">MySQL语法基础-管理篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/date-types">MySQL数据类型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/functions-and-operators">运算符和常用函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/storage-engines">MySQL存储引擎</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/sql-indexes">MySQL 索引</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/mysql/sql-execute-procedure">一条SQL的执行过程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/innodb-isolation">InnoDB 存储引擎的事务隔离特性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/mvcc">MySQL MVCC 多版本并发控制原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/explain-cmd">EXPLAIN 命令详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/数据库索引失效的几种场景">数据库索引失效的几种场景</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/sql-optimize">SQL优化的技巧</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql/event-scheduler">MySQL定时任务(Event Scheduler)</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/服务器运维">服务器运维</a><button aria-label="打开/收起侧边栏菜单「服务器运维」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/spring">Spring</a><button aria-label="打开/收起侧边栏菜单「Spring」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/框架和中间件">框架和中间件</a><button aria-label="打开/收起侧边栏菜单「框架和中间件」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/redis">Redis</a><button aria-label="打开/收起侧边栏菜单「Redis」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/开发工具">开发工具</a><button aria-label="打开/收起侧边栏菜单「开发工具」" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>一条SQL的执行过程</h1></header><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="mysql-连接">MySQL 连接<a class="hash-link" href="#mysql-连接" title="标题的直接链接">​</a></h2><p>在系统与MySQL进行交互前，MySQL 驱动会帮我们建立好连接，为方便系统关联连接，一般会引入数据库连接池。另一方面，MySQL 架构体系中也提供了连接池，如下图所示</p><p><img loading="lazy" src="/assets/images/20230409154748-716f0422925223df7e6dbf7efcced6c5.png" width="1080" height="424" class="img_ev3q"></p><p>网络连接必须由线程来处理，网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都会有相应的线程去处理的。也就是说对于 SQL 语句的请求在 MySQL  中是由一个个的线程去处理的。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="mysql-server-层">MySQL Server 层<a class="hash-link" href="#mysql-server-层" title="标题的直接链接">​</a></h2><p>MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括连接器、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li><li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始就被当做默认存储引擎了。</li></ul><p><strong>Server 层主要组件的作用</strong></p><ul><li>连接器： 身份认证和权限相关(登录 MySQL 的时候)。</li><li>分析器: 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li>优化器： 按照 MySQL 认为最优的方案去执行。</li><li>执行器: 执行语句，然后从存储引擎返回数据。</li></ul><p><img loading="lazy" src="/assets/images/20230409160819-6f9e42b7fe7d8aa0850ba0982d060742.png" width="1080" height="470" class="img_ev3q"></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="连接器">连接器<a class="hash-link" href="#连接器" title="标题的直接链接">​</a></h3><p>连接器负责跟 <strong>客户端建立连接、获取权限、维持和管理连接</strong>。</p><ul><li>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</li><li>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 <strong>show processlist</strong> 命令中看到它</li><li>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <strong>wait_timeout</strong> 控制的，默认值是 8 小时</li><li>数据库里面，<strong>长连接</strong> 是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。<strong>短连接</strong> 则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li></ul><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>查询缓存</div><div class="admonitionContent_S0QG"><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p><p><strong>如果表更改，则使用该表的所有高速缓存查询都变为无效并从缓存中删除</strong>，可以看出缓存是很容易失效的。</p><p>在大多数情况下我们都是不推荐去使用查询缓存。在8.0之后，MySQL 移除了查询缓存。</p></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="解析器">解析器<a class="hash-link" href="#解析器" title="标题的直接链接">​</a></h3><p>对客户端传来的 sql 进行分析，这将包括预处理与解析过程，并进行关键词的提取、解析，并组成一个解析树。具体的解析词包括但不局限于 select/update/delete/or/in/where/group by/having/count/limit 等，如果分析到语法错误，会直接抛给客户端异常：ERROR:You have an error in your SQL syntax.</p><p>比如：<code>select *  from user where userId =1234</code>;</p><p>在分析器中就通过语义规则器将select from where这些关键词提取和匹配出来,mysql会自动判断关键词和非关键词，将用户的匹配字段和自定义语句识别出来。这个阶段也会做一些校验:比如校验当前数据库是否存在user表，同时假如User表中不存在userId这个字段同样会报错：<strong>unknown column in field list.</strong></p><p><strong>结论：分析器主要对SQL进行解析，包括关键字的提取、解析、检查SQL的语法是否正确。</strong></p><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="优化器">优化器<a class="hash-link" href="#优化器" title="标题的直接链接">​</a></h3><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优）。MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本。</p><p>优化器会根据扫描行数、是否使用临时表、是否排序等来判断是否使用某个索引，其中扫描行数的计算可以通过统计信息来估算得出，而统计信息可以看作是索引唯一数的数量，可以使用部分采样来估算，具体就是选择 N 个数据页，统计这些页上数据的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了。但是因为索引数据会变化，所以索引的统计信息也会变化。当变更的数据行数超过 1/M 的时候，就会重新计算一次统计信息。</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>没有使用最优索引如何优化</div><div class="admonitionContent_S0QG"><p>1、虽然会自动更新统计信息，但是但是不能保证统计信息是最新值，这就可能导致优化器选择了不同的索引导致执行变慢，所以可以通过 &quot; analyze  table 表名&quot; 来重新计算索引的统计信息。</p><p>2、在表名后面添加 &quot; force index(索引名) &quot; 语句来强制使用索引</p><p>3、将 sql 进行修改成优化器可以选最优索引的实现方式。</p><p>4、新建一个最优索引或者删除优化器误用的索引。</p></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="执行器">执行器<a class="hash-link" href="#执行器" title="标题的直接链接">​</a></h3><p>执行器会调用对应的存储引擎执行 sql。主流的是MyISAM 和 Innodb。</p><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p><p>这个时候执行权限校验的原因是：sql执行过程中可能会有触发器这种在运行时才能确定的过程，分析器工作结束后的precheck是不能对这种运行时涉及到的表进行权限校验的，所以需要在执行器阶段进行权限检查</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="mysql-存储引擎层">MySQL 存储引擎层<a class="hash-link" href="#mysql-存储引擎层" title="标题的直接链接">​</a></h2><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">UPDATE</span><span class="token plain"> students </span><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> stuName </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;小强&#x27;</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在执行 SQL 的时候 SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：缓冲池 Buffer Pool。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="buffer-pool">Buffer Pool<a class="hash-link" href="#buffer-pool" title="标题的直接链接">​</a></h3><p>Buffer Pool （缓冲池）是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实就是类似  Redis  一样的作用，起到一个缓存的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Pool  那么我们每次的数据库请求都会磁盘中查找，这样必然会存在 IO 操作，这肯定是无法接受的。但是有了 Buffer Pool 就是我们第一次在查询的时候会将查询的结果存到  Buffer Pool 中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到  Buffer Pool 中，如下图</p><p><img loading="lazy" src="/assets/images/20230409171408-7730fd5d290b1dc7def0f9f7bfe655c3.png" width="484" height="308" class="img_ev3q"></p><p>按照上面的那幅图，这条 SQL 语句的执行步骤大致是这样子的</p><ol><li>innodb 存储引擎会在缓冲池中查找 id=1 的这条数据是否存在</li><li>发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中</li><li>该条记录会被加上一个独占锁（总不能你在修改的时候别人也在修改吧）</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="undo-日志文件记录数据被修改前的样子">undo 日志文件：记录数据被修改前的样子<a class="hash-link" href="#undo-日志文件记录数据被修改前的样子" title="标题的直接链接">​</a></h3><p>我们刚刚已经说了，在准备更新一条语句的时候，该条语句已经被加载到 Buffer pool 中了，实际上这里还有这样的操作，就是在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来。</p><p>这样做的目的是什么？</p><p>Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响，看图说话</p><p><img loading="lazy" src="/assets/images/20230409171030-f9a628b9db45f3cc056aa8ab63358835.png" width="596" height="326" class="img_ev3q"></p><p>这里说句额外话，其实 MySQL  也是一个系统，就好比我们平时开发的 java 的功能系统一样，MySQL  使用的是自己相应的语言开发出来的一套系统而已，它根据自己需要的功能去设计对应的功能，它即然能做到哪些事情，那么必然是设计者们当初这么定义或者是根据实际的场景变更演化而来的。所以大家放平心态，把 MySQL 当作一个系统去了解熟悉他。</p><p>到这一步，我们的执行的 SQL 语句已经被加载到 Buffer Pool 中了，然后开始更新这条语句，更新的操作实际是在Buffer Pool中执行的，那问题来了，按照我们平时开发的一套理论缓冲池中的数据和数据库中的数据不一致时候，我们就认为缓存中的数据是脏数据，那此时 Buffer Pool 中的数据岂不是成了脏数据？没错，目前这条数据就是脏数据，Buffer Pool 中的记录是小强 数据库中的记录是旺财 ，这种情况 MySQL是怎么处理的呢，继续往下看</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="redo-日志文件记录数据被修改后的样子">redo 日志文件：记录数据被修改后的样子<a class="hash-link" href="#redo-日志文件记录数据被修改后的样子" title="标题的直接链接">​</a></h3><p>除了从磁盘中加载文件和将操作前的记录保存到 undo 日志文件中，其他的操作是在内存中完成的，内存中的数据的特点就是：断电丢失。如果此时 MySQL 所在的服务器宕机了，那么 Buffer Pool 中的数据会全部丢失的。这个时候 redo 日志文件就需要来大显神通了</p><p>画外音：redo 日志文件是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的</p><p>redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来，例如，此时将要做的是update students set stuName=&#x27;小强&#x27; where id=1; 那么这条操作就会被记录到 redo log buffer 中，啥？怎么又出来一个 redo log buffer ,很简单，MySQL 为了提高效率，所以将这些操作都先放在内存中去完成，然后会在<strong>某个时机</strong>将其持久化到磁盘中。</p><p><img loading="lazy" src="/assets/images/20230409171901-851365efe35da3277cdd14bcb09625b2.png" width="923" height="361" class="img_ev3q"></p><p>截至目前，我们应该都熟悉了 MySQL 的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志的，流程如下：</p><p>1）准备更新一条 SQL 语句</p><p>2）MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中</p><p>3）在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</p><p>4）innodb 会在 Buffer Pool 中执行更新操作</p><p>5）更新后的数据会记录在 redo log buffer 中</p><p>上面说的步骤都是在正常情况下的操作，但是程序的设计和优化并不仅是为了这些正常情况而去做的，也是为了那些临界区和极端情况下出现的问题去优化设计的</p><p>这个时候如果服务器宕机了，那么缓存中的数据还是丢失了。真烦，竟然数据总是丢失，那能不能不要放在内存中，直接保存到磁盘呢？很显然不行，因为在上面也已经介绍了，在内存中的操作目的是为了提高效率。</p><p>此时，如果 MySQL 真的宕机了，那么没关系的，因为 MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。</p><p>好了，语句也更新好了那么需要将更新的值提交啊，也就是需要提交本次的事务了，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作</p><p>将  redo Log Buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写入到 redo log 磁盘文件中，一般情况下，redo log Buffer 数据写入磁盘的策略是立即刷入磁盘（具体策略情况在下面小总结出会详细介绍）,上图</p><p><img loading="lazy" src="/assets/images/20230409172238-adace19d64194f0f9d0f1a01617b06dd.png" width="919" height="365" class="img_ev3q"></p><p>如果 redo log Buffer 刷入磁盘后，数据库服务器宕机了，那我们更新的数据怎么办？此时数据是在内存中，数据岂不是丢失了？不，这次数据就不会丢失了，因为 redo log buffer 中的数据已经被写入到磁盘了，已经被持久化了，就算数据库宕机了，在下次重启的时候 MySQL 也会将 redo 日志文件内容恢复到 Buffer Pool 中（这边我的理解是和  Redis  的持久化机制是差不多的，在  Redis  启动的时候会检查 rdb 或者是 aof 或者是两者都检查，根据持久化的文件来将数据恢复到内存中）</p><p>到此为止，从执行器开始调用存储引擎接口做了哪些事情呢？</p><p>1）准备更新一条 SQL 语句</p><p>2）MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中 </p><p>3）在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</p><p>4）innodb 会在 Buffer Pool 中执行更新操作</p><p>5）更新后的数据会记录在 redo log buffer 中</p><p>---到此是前面已经总结过的---</p><p>6）MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中 刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置</p><ul><li>值为 0 表示不刷入磁盘</li><li>值为 1 表示立即刷入磁盘</li><li>值为 2 表示先刷到 os cache</li></ul><p>7）myslq 重启的时候会将 redo 日志恢复到缓冲池中</p><p><strong>redo log 的写入拆成了两个步骤：prepare 和 commit，这就是&quot;两阶段提交&quot;</strong>。在更新到数据页缓存或者 Change Buffer 后，<strong>首先进行 redo log 的编写，编写完成后将 redo log 设为 prepare 状态，随后再进行 binlog 的编写，等到 binlog 也编写完成后再将 redo log 设置为 commit 状态</strong>。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="bin-log-日志文件记录整个操作过程">bin log 日志文件：记录整个操作过程<a class="hash-link" href="#bin-log-日志文件记录整个操作过程" title="标题的直接链接">​</a></h3><p>上面介绍到的redo log是  InnoDB  存储引擎特有的日志文件，而bin log属于是  MySQL  级别的日志。redo log记录的东西是偏向于物理性质的，如：“对什么数据，做了什么修改”。bin log是偏向于逻辑性质的，类似于：“对 students 表中的 id 为 1 的记录做了更新操作” 两者的主要特点总结如下:</p><table><thead><tr><th>性质</th><th>redo log</th><th>bin log</th></tr></thead><tbody><tr><td>文件大小</td><td>redo log 的大小是固定的（配置中也可以设置，一般默认的就足够了）</td><td>bin log 可通过配置参数<code>max_bin log_size</code>设置每个<code>bin log</code>文件的大小（但是一般不建议修改）。</td></tr><tr><td>实现方式</td><td><code>redo log</code>是<code>InnoDB</code>引擎引擎独有的</td><td><code>bin log</code>是  MySQL Server 层实现的，所有引擎都可以使用 <code>bin log</code>日志</td></tr><tr><td>记录方式</td><td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td><td>bin log 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td></tr><tr><td>使用场景</td><td><code>redo log</code>适用于崩溃恢复(crash-safe)（这一点其实非常类似与 Redis 的持久化特征）</td><td><code>bin log</code> 适用于主从复制和数据恢复</td></tr></tbody></table><p><strong>redo log 循环写</strong></p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。</p><p><img loading="lazy" src="/assets/images/20230409180321-6bd732d35caadfde40c5c743f28a1cdf.png" width="448" height="430" class="img_ev3q"></p><p><strong>bin log文件是如何刷入磁盘的?</strong></p><p>bin log 的刷盘是有相关的策略的，策略可以通过sync_bin log来修改，默认为 0，表示先写入 os cache，也就是说在提交事务的时候，数据不会直接到磁盘中，这样如果宕机bin log数据仍然会丢失。所以建议将sync_bin log设置为 1 表示直接将数据写入到磁盘文件中。</p><p><strong>刷入 bin log 有以下几种模式</strong></p><p>1、 STATMENT</p><p>基于 SQL 语句的复制(statement-based replication, SBR)，每一条会修改数据的 SQL 语句会记录到 bin log 中</p><p>【优点】：不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</p><p>【缺点】：在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等</p><p>2、ROW</p><p>基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了</p><p>【优点】：不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</p><p>【缺点】：会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</p><p>3、MIXED</p><p>基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log</p><p><strong>那既然bin log也是日志文件，那它是在什么时候记录数据的呢？</strong></p><p>其实 MySQL 在提交事务的时候，不仅仅会将 redo log buffer  中的数据写入到redo log 文件中，同时也会将本次修改的数据记录到 bin log文件中，同时会将本次修改的bin log文件名和修改的内容在bin log中的位置记录到redo log中，最后还会在redo log最后写入 commit 标记，这样就表示本次事务被成功的提交了。</p><p><img loading="lazy" src="/assets/images/20230409173943-2ffa66c155ff9f1c47c2db62f3575930.png" width="1055" height="644" class="img_ev3q"></p><p><strong>如果在数据被写入到bin log文件的时候，刚写完，数据库宕机了，数据会丢失吗？</strong></p><p>首先可以确定的是，只要redo log最后没有 commit 标记，说明本次的事务一定是失败的。但是数据是没有丢失了，因为已经被记录到redo log的磁盘文件中了。在 MySQL 重启的时候，就会将 redo log 中的数据恢复（加载）到Buffer Pool中。</p><p>好了，到目前为止，一个更新操作我们基本介绍得差不多，但是你有没有感觉少了哪件事情还没有做？是不是你也发现这个时候被更新记录仅仅是在内存中执行的，哪怕是宕机又恢复了也仅仅是将更新后的记录加载到Buffer Pool中，这个时候 MySQL 数据库中的这条记录依旧是旧值，也就是说内存中的数据在我们看来依旧是脏数据，那这个时候怎么办呢？</p><p>其实 MySQL 会有一个后台线程，它会在某个时机将我们Buffer Pool中的脏数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了。</p><p><img loading="lazy" src="/assets/images/20230409174133-f6c56a4203b96a3c9fafdffea52a802f.png" width="1051" height="652" class="img_ev3q"></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="总结更新一条数据到事务提交的流程">总结：更新一条数据到事务提交的流程<a class="hash-link" href="#总结更新一条数据到事务提交的流程" title="标题的直接链接">​</a></h3><p>1）首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</p><p>2）在数据被缓存到缓存池的同时，会写入 undo log 日志文件</p><p>3）更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</p><p>4）完成以后就可以提交事务，在提交的同时会做以下三件事</p><p>5）（第一件事）将redo log buffer中的数据刷入到 redo log 文件中</p><p>6）（第二件事）将本次操作记录写入到 bin log文件中</p><p>7）（第三件事）将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="三个日志的比较">三个日志的比较<a class="hash-link" href="#三个日志的比较" title="标题的直接链接">​</a></h3><p>1、undo log是用于事务的回滚、保证事务隔离级别读已提交、可重复读实现的。redo log是用于对暂不更新到磁盘上的操作进行记录，使得其可以延迟落盘，保证程序的效率。bin log是对数据操作进行备份恢复（并不能依靠 bin log 直接完成数据恢复）。</p><p>2、undo log 与 redo log 是存储引擎层的日志，只能在 InnoDB 下使用；而bin log 是 Server 层的日志，可以在任何引擎下使用。</p><p>3、redo log 大小有限，超过后会循环写；另外两个大小不会。</p><p>4、undo log 记录的是行记录变化前的数据；redo log 记录的是 sql 的数据页修改逻辑以及 change buffer 的变更；bin log记录操作语句对具体行的操作以及操作前的整行信息（5.7默认）或者sql语句。</p><p>5、单独的 binlog 没有 crash-safe 能力，也就是在异常断电后，之前已经提交但未更新的事务操作到磁盘的操作会丢失，也就是主从复制的一致性无法保障，而 redo log 有 crash-safe 能力，通过与 redo log 的配合实现 &quot;三步提交&quot;，就可以让主从库的数据也能保证一致性。</p><p>6、redo log 是物理日志，它记录的是数据页修改逻辑以及 change buffer 的变更，只能在当前存储引擎下使用，而 binlog 是逻辑日志，它记录的是操作语句涉及的每一行修改前后的值，在任何存储引擎下都可以使用。</p><p><strong>MySQL 是 WAL（Write-Ahead Logging）机制，也就是写操作会先存入日志，然后再写入磁盘，这样可以避开高峰，提高数据库的可用性。</strong></p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="查询-和-更新-流程图">查询 和 更新 流程图<a class="hash-link" href="#查询-和-更新-流程图" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="更新">更新<a class="hash-link" href="#更新" title="标题的直接链接">​</a></h3><p><img loading="lazy" src="/assets/images/20230409180007-d3c9f87d19df36dba93d8645dafb6b98.png" width="851" height="762" class="img_ev3q"></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="查询">查询<a class="hash-link" href="#查询" title="标题的直接链接">​</a></h3><p><img loading="lazy" src="/assets/images/20230409180037-101e9ed5412b5a673de5f1d4504e02d4.png" width="972" height="993" class="img_ev3q"></p><hr><p>参考</p><ul><li>详解一条 SQL 的执行过程：<a href="https://blog.csdn.net/weixin_41385912/article/details/112975752" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_41385912/article/details/112975752</a></li><li>一条 sql 的执行过程详解：<a href="https://www.cnblogs.com/mengxinJ/p/14045520.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/mengxinJ/p/14045520.html</a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/my-sql">MySQL</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">最后<!-- -->由 <b>Hans</b> <!-- -->于 <b><time datetime="2023-04-09T10:07:00.000Z">2023年4月9日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/mysql/sql-indexes"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">MySQL 索引</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/mysql/innodb-isolation"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">InnoDB 存储引擎的事务隔离特性</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#mysql-连接" class="table-of-contents__link toc-highlight">MySQL 连接</a></li><li><a href="#mysql-server-层" class="table-of-contents__link toc-highlight">MySQL Server 层</a><ul><li><a href="#连接器" class="table-of-contents__link toc-highlight">连接器</a></li><li><a href="#解析器" class="table-of-contents__link toc-highlight">解析器</a></li><li><a href="#优化器" class="table-of-contents__link toc-highlight">优化器</a></li><li><a href="#执行器" class="table-of-contents__link toc-highlight">执行器</a></li></ul></li><li><a href="#mysql-存储引擎层" class="table-of-contents__link toc-highlight">MySQL 存储引擎层</a><ul><li><a href="#buffer-pool" class="table-of-contents__link toc-highlight">Buffer Pool</a></li><li><a href="#undo-日志文件记录数据被修改前的样子" class="table-of-contents__link toc-highlight">undo 日志文件：记录数据被修改前的样子</a></li><li><a href="#redo-日志文件记录数据被修改后的样子" class="table-of-contents__link toc-highlight">redo 日志文件：记录数据被修改后的样子</a></li><li><a href="#bin-log-日志文件记录整个操作过程" class="table-of-contents__link toc-highlight">bin log 日志文件：记录整个操作过程</a></li><li><a href="#总结更新一条数据到事务提交的流程" class="table-of-contents__link toc-highlight">总结：更新一条数据到事务提交的流程</a></li><li><a href="#三个日志的比较" class="table-of-contents__link toc-highlight">三个日志的比较</a></li></ul></li><li><a href="#查询-和-更新-流程图" class="table-of-contents__link toc-highlight">查询 和 更新 流程图</a><ul><li><a href="#更新" class="table-of-contents__link toc-highlight">更新</a></li><li><a href="#查询" class="table-of-contents__link toc-highlight">查询</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Hans | <a href="https://beian.miit.gov.cn/">苏ICP备2021046511号</a> | Built with <a href="https://docusaurus.io/zh-CN/">Docusaurus</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.a5c98095.js"></script>
<script src="/assets/js/main.e7217a4b.js"></script>
</body>
</html>